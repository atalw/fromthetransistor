`include "tlb.v"
`include "table_walk.v"
// The MMU translates VAs generated by the CPU core, and by CP15 register 13 (not implemented),
// into physical addresses to access external memory.
// It also derives and checks the access permission, using a TLB. (not implemented)
// The MMU table walking hardware is used to add entries to the TLB. The translation information,
// that comprises both the address translation data and the access permission data, resides in a
// translation table located in physical memory. The MMU provides the logic for you to traverse this
// translation table and load entries into the TLB.
//
// In ARM9, CPU gives MMU a Modified virtual address (MVA).
// MVA = Page table index(31:20) + Section index(19:0)
//
// ARM9 spec uses 32-bit addresses but that means we'll have to create
// a memory region of 2^32/32(word width) bytes. That's HUGE, so in the
// interest of dev, we'll only support 14-bit addresses = 16kB memory.
module mmu(
    input   wire        in_clk,
    input   wire        in_en,
    input   wire [13:0] in_mva,
    input   wire [13:0] in_tlb_paddr, // output of the tlb
    output  wire [13:0] out_tlb_mva, // input to the tlb
    output  wire [13:0] out_paddr
    );

    reg [13:0] r_paddr;

    reg w_tlb_clk;
    reg w_tlb_ren;
    wire w_tlb_err;
    wire [13:0] w_tlb_paddr;

    reg w_table_walk_clk;
    reg w_table_walk_en;
    wire [13:0] w_table_walk_paddr;

    assign out_paddr = r_paddr;

    tlb tlb(
        .in_clk(w_tlb_clk),
        .in_ren(w_tlb_ren),
        .in_mva(in_mva),
        .out_err(w_tlb_err),
        .out_paddr(w_tlb_paddr)
    );


    table_walk table_walk(
        .in_clk(w_table_walk_clk),
        .in_en(w_table_walk_en),
        .in_mva(in_mva),
        .out_paddr(w_table_walk_paddr),

        .in_mcu_data(),
        .out_mcu_ren(),
        .out_mcu_addr(),
        .out_mcu_size()
    );

    always @(posedge in_clk) begin
        w_tlb_clk <= in_clk;
        w_table_walk_clk <= in_clk;

        if (in_en) begin
            // Try TLB first
            if (~w_tlb_err) begin
                w_tlb_ren <= 1;
                // If TLB hit
                if (w_tlb_paddr) begin
                    r_paddr <= w_tlb_paddr;
                end
            end else begin
                w_table_walk_en <= 1;
                if (w_table_walk_paddr) begin
                    r_paddr <= w_table_walk_paddr;
                end
            end
        end else begin
            w_tlb_ren <= 0;
            w_table_walk_en <= 0;
            r_paddr <= 0;
        end
    end
endmodule
