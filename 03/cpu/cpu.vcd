$date
	Sat Jun 18 16:21:57 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module control_unit_tb $end
$var wire 32 ! out_Rn_val [31:0] $end
$var wire 14 " pc [13:0] $end
$var reg 1 # clock $end
$var reg 4 $ in_Rn [3:0] $end
$var reg 1 % nreset $end
$scope module control_unit $end
$var wire 1 # clock $end
$var wire 1 % nreset $end
$var wire 1 & ram_Write_enable $end
$var wire 1 ' w_Writeback $end
$var wire 5 ( w_Shift_val [4:0] $end
$var wire 2 ) w_Shift_type [1:0] $end
$var wire 1 * w_Set_cond $end
$var wire 4 + w_Rs [3:0] $end
$var wire 4 , w_Rotate [3:0] $end
$var wire 4 - w_Rn [3:0] $end
$var wire 4 . w_Rm [3:0] $end
$var wire 4 / w_Rd [3:0] $end
$var wire 4 0 w_Opcode [3:0] $end
$var wire 32 1 w_Op2_val [31:0] $end
$var wire 4 2 w_Instruction_type [3:0] $end
$var wire 32 3 w_Instruction [31:0] $end
$var wire 4 4 w_Instr_CNZV [3:0] $end
$var wire 32 5 w_Imm_val [31:0] $end
$var wire 1 6 w_Carry $end
$var wire 4 7 w_CNZV [3:0] $end
$var wire 32 8 w_Alu_res [31:0] $end
$var wire 32 9 in_Rn_val [31:0] $end
$var wire 32 : in_Op2_val [31:0] $end
$var reg 14 ; pc [13:0] $end
$var reg 14 < ram_Addr [13:0] $end
$var reg 2 = ram_Size [1:0] $end
$var reg 32 > ram_Wdata [31:0] $end
$scope module alu $end
$var wire 4 ? out_CNZV [3:0] $end
$var wire 1 ' out_Writeback $end
$var wire 32 @ out_Y [31:0] $end
$var wire 1 * in_Set_cond $end
$var wire 32 A in_Rn [31:0] $end
$var wire 4 B in_Opcode [3:0] $end
$var wire 32 C in_Op2 [31:0] $end
$var wire 4 D in_CNZV [3:0] $end
$var wire 1 6 in_Barrel_carry $end
$var wire 32 E ad_Y [31:0] $end
$var wire 4 F ad_CNZV [3:0] $end
$var reg 1 G ad_Carry $end
$var reg 32 H ad_Op2 [31:0] $end
$var reg 32 I ad_Rn [31:0] $end
$var reg 4 J r_CNZV [3:0] $end
$var reg 1 K r_Writeback $end
$var reg 32 L r_Y [31:0] $end
$scope module adder $end
$var wire 1 G in_Carry $end
$var wire 32 M in_Op2 [31:0] $end
$var wire 32 N in_Rn [31:0] $end
$var wire 4 O out_CNZV [3:0] $end
$var wire 32 P out_Y [31:0] $end
$var reg 4 Q r_CNZV [3:0] $end
$var reg 32 R r_Y [31:0] $end
$var integer 32 S idx [31:0] $end
$scope function one_bit_add $end
$var reg 1 T a $end
$var reg 1 U b $end
$var reg 1 V carry $end
$upscope $end
$upscope $end
$upscope $end
$scope module decoder $end
$var wire 4 W out_Instruction_type [3:0] $end
$var wire 4 X out_Opcode [3:0] $end
$var wire 4 Y out_Rd [3:0] $end
$var wire 4 Z out_Rm [3:0] $end
$var wire 4 [ out_Rn [3:0] $end
$var wire 4 \ out_Rotate [3:0] $end
$var wire 4 ] out_Rs [3:0] $end
$var wire 1 * out_Set_cond $end
$var wire 2 ^ out_Shift_type [1:0] $end
$var wire 5 _ out_Shift_val [4:0] $end
$var wire 32 ` out_Imm [31:0] $end
$var wire 4 a out_CNZV [3:0] $end
$var wire 32 b in_Instruction [31:0] $end
$var reg 4 c r_CNZV [3:0] $end
$var reg 8 d r_Imm [7:0] $end
$var reg 4 e r_Instruction_type [3:0] $end
$var reg 4 f r_Opcode [3:0] $end
$var reg 4 g r_Rd [3:0] $end
$var reg 4 h r_Rm [3:0] $end
$var reg 4 i r_Rn [3:0] $end
$var reg 4 j r_Rotate [3:0] $end
$var reg 4 k r_Rs [3:0] $end
$var reg 1 l r_Set_cond $end
$var reg 2 m r_Shift_type [1:0] $end
$var reg 8 n r_Shift_val [7:0] $end
$scope function classify_instr $end
$var reg 1 o instruction $end
$upscope $end
$scope task extract_data $end
$var reg 1 p instruction_type $end
$upscope $end
$upscope $end
$scope module ram $end
$var wire 1 # clock $end
$var wire 14 q in_Addr [13:0] $end
$var wire 2 r in_Size [1:0] $end
$var wire 32 s in_Wdata [31:0] $end
$var wire 1 & in_Write $end
$var reg 32 t out_Rdata [31:0] $end
$var reg 32 u r_Rdata [31:0] $end
$upscope $end
$scope module register_bank $end
$var wire 1 # clock $end
$var wire 4 v in_Read_address1 [3:0] $end
$var wire 4 w in_Read_address2 [3:0] $end
$var wire 4 x in_Write_address1 [3:0] $end
$var wire 32 y in_Write_data1 [31:0] $end
$var wire 1 ' in_Write_enable $end
$var reg 32 z out_Data1 [31:0] $end
$var reg 32 { out_Data2 [31:0] $end
$upscope $end
$scope module shifter $end
$var wire 1 | in_C_flag $end
$var wire 32 } in_Imm_val [31:0] $end
$var wire 32 ~ in_Reg_val [31:0] $end
$var wire 4 !" in_Rotate [3:0] $end
$var wire 2 "" in_Shift_type [1:0] $end
$var wire 5 #" in_Shift_val [4:0] $end
$var wire 1 6 out_Carry $end
$var wire 32 $" out_Op2 [31:0] $end
$var reg 1 %" r_Carry $end
$var reg 32 &" r_Op2 [31:0] $end
$scope task exec_shift $end
$var reg 5 '" is_reg [4:0] $end
$var reg 5 (" shift_val [4:0] $end
$var reg 32 )" val [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope begin $unm_blk_87 $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx )"
bx ("
bx '"
bx &"
x%"
bx $"
bx #"
bx ""
bx !"
bx ~
b0xxxxxxxx }
x|
bx {
bx z
bx y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
bx q
xp
xo
bx n
bx m
xl
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
b0xxxxxxxx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
xV
xU
xT
b0 S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
xK
bx J
bx I
bx H
xG
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
x6
b0xxxxxxxx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
x*
bx )
bx (
x'
z&
1%
bx $
0#
bx "
bz !
$end
#10
b10 =
b10 r
b0 "
b0 ;
1#
#20
0#
#30
b0 <
b0 q
1#
#40
0#
#50
b100000 S
b100 E
b100 P
b100 R
0T
0U
0V
b0 F
b0 O
b0 Q
06
0%"
b100 1
b100 C
b100 $"
b100 &"
b0 '"
b0 ("
b100 )"
b0 9
b0 A
b0 z
0|
1'
1K
b0 7
b0 ?
b0 J
b100 8
b100 @
b100 y
b100 L
0G
b100 H
b100 M
b0 I
b0 N
b11 )
b11 ^
b11 ""
b11 m
b0 ,
b0 \
b0 !"
b0 j
b100 5
b100 `
b100 }
b100 d
b0 /
b0 Y
b0 x
b0 g
b0 -
b0 [
b0 v
b0 i
b100 0
b100 B
b100 X
b100 f
0*
0l
b0 4
b0 D
b0 a
b0 c
1p
b1 2
b1 W
b1 e
0o
b10100000000000000000000100 3
b10100000000000000000000100 b
b10100000000000000000000100 t
b10100000000000000000000100 u
1#
#60
0#
#70
1#
#80
0#
#90
1#
#100
0#
b0 $
