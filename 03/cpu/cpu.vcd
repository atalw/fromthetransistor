$date
	Tue Jun 14 21:44:05 2022
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module control_unit $end
$var wire 32 ! in_Instruction [31:0] $end
$var wire 32 " in_Op2_val [31:0] $end
$var wire 32 # in_Rn_val [31:0] $end
$var wire 1 $ in_Set_cond $end
$var wire 5 % in_Shift_imm [4:0] $end
$var wire 2 & in_Shift_type [1:0] $end
$var wire 4 ' out_Instr_CNZV [3:0] $end
$var wire 8 ( out_Shift [7:0] $end
$var wire 1 ) out_Set_cond $end
$var wire 4 * out_Rs [3:0] $end
$var wire 4 + out_Rotate [3:0] $end
$var wire 4 , out_Rn [3:0] $end
$var wire 4 - out_Rm [3:0] $end
$var wire 4 . out_Rd [3:0] $end
$var wire 4 / out_Opcode [3:0] $end
$var wire 32 0 out_Op2_val [31:0] $end
$var wire 4 1 out_Instruction_type [3:0] $end
$var wire 8 2 out_Imm [7:0] $end
$var wire 1 3 out_Carry $end
$var wire 4 4 out_CNZV [3:0] $end
$var wire 32 5 out_Alu_res [31:0] $end
$scope module alu $end
$var wire 4 6 in_CNZV [3:0] $end
$var wire 32 7 in_Rn [31:0] $end
$var wire 1 $ in_Set_cond $end
$var wire 4 8 out_CNZV [3:0] $end
$var wire 32 9 out_Y [31:0] $end
$var wire 4 : in_Opcode [3:0] $end
$var wire 32 ; in_Op2 [31:0] $end
$var wire 1 3 in_Barrel_carry $end
$var wire 32 < ad_Y [31:0] $end
$var wire 4 = ad_CNZV [3:0] $end
$var reg 1 > ad_Carry $end
$var reg 32 ? ad_Op2 [31:0] $end
$var reg 32 @ ad_Rn [31:0] $end
$var reg 4 A r_CNZV [3:0] $end
$var reg 32 B r_Y [31:0] $end
$scope module adder $end
$var wire 1 > in_Carry $end
$var wire 32 C in_Op2 [31:0] $end
$var wire 32 D in_Rn [31:0] $end
$var wire 4 E out_CNZV [3:0] $end
$var wire 32 F out_Y [31:0] $end
$var reg 4 G r_CNZV [3:0] $end
$var reg 32 H r_Y [31:0] $end
$var integer 32 I idx [31:0] $end
$scope function one_bit_add $end
$var reg 1 J a $end
$var reg 1 K b $end
$var reg 1 L carry $end
$upscope $end
$upscope $end
$upscope $end
$scope module decoder $end
$var wire 32 M in_Instruction [31:0] $end
$var wire 4 N out_CNZV [3:0] $end
$var wire 8 O out_Imm [7:0] $end
$var wire 4 P out_Instruction_type [3:0] $end
$var wire 4 Q out_Opcode [3:0] $end
$var wire 4 R out_Rd [3:0] $end
$var wire 4 S out_Rm [3:0] $end
$var wire 4 T out_Rn [3:0] $end
$var wire 4 U out_Rotate [3:0] $end
$var wire 4 V out_Rs [3:0] $end
$var wire 1 ) out_Set_cond $end
$var wire 8 W out_Shift [7:0] $end
$var reg 4 X r_CNZV [3:0] $end
$var reg 8 Y r_Imm [7:0] $end
$var reg 4 Z r_Instruction_type [3:0] $end
$var reg 4 [ r_Opcode [3:0] $end
$var reg 4 \ r_Rd [3:0] $end
$var reg 4 ] r_Rm [3:0] $end
$var reg 4 ^ r_Rn [3:0] $end
$var reg 4 _ r_Rotate [3:0] $end
$var reg 4 ` r_Rs [3:0] $end
$var reg 1 a r_Set_cond $end
$var reg 8 b r_Shift [7:0] $end
$scope function classify_instr $end
$var reg 1 c instruction $end
$upscope $end
$scope task extract_data $end
$var reg 1 d instruction_type $end
$upscope $end
$upscope $end
$scope module shifter $end
$var wire 1 e in_C_flag $end
$var wire 5 f in_Shift_imm [4:0] $end
$var wire 2 g in_Shift_type [1:0] $end
$var wire 32 h in_Val [31:0] $end
$var wire 1 3 out_Carry $end
$var wire 32 i out_Op2 [31:0] $end
$var reg 1 j r_Carry $end
$var reg 32 k r_Op2 [31:0] $end
$upscope $end
$upscope $end
